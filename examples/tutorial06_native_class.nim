#====================================================================
#
#             NimPK - PocketLang Binding for Nim
#                  Copyright (c) 2022 Ward
#
#====================================================================

import std/[strformat, random]
import nimpk
import nimpk/src

withNimPkVm:
  # Native class for PocketLang is a class with ctor and dtor in native
  # code. Type-binding class is also native class, but ctor and dtor are
  # automatically generated by NimPk. Here demonstrate a native class
  # with custom ctor and dtor.

  # ctor:
  #  - Will be called when the instance is constructed (before _init).
  #  - Injected symbol for ctor: `vm`.
  #  - Return value of ctor must be a pointer (it become `this` in dtor).
  #  - In binded code block or dtor, use `this` to get the pointer.
  #  - In binded procedure, use self.this or self.native to get the pointer.

  # dtor:
  #  - Will be invoked at the GC execution.
  #  - Injected symbol for dtor: `vm`, `this`.
  #  - No return value.
  #  - No object allocations are allowed during it.
  randomize()
  var total = 0

  vm.def:
    getTotal:
      return total

    [Module]:
      [Class]:
        ctor:
          var count = rand(1024..4096)
          var this = alloc0(count)
          cast[ptr int](this)[] = count
          total += count
          return this

        dtor:
          total -= cast[ptr int](this)[]
          dealloc(this)

        count do (self: NpVar) -> int:
          return cast[ptr int](self.this)[]

  vm.run """
    import lang
    from Module import Class

    total = 0
    for i in 0..100
      total += Class().count()
    end

    assert getTotal() == total
    lang.gc()
    assert getTotal() == 0
  """

  # Native class and script class can inherit or be inherited from each other.
  vm.def:
    [+Module]: # `+` means modity instead of replace
      [Inherit1] is [Class] # `is` for inheriting, the same syntax in PocketLang.

  vm.run """
    import lang
    from Module import Class, Inherit1

    # Script class inherited from native class.
    class Inherit2 is Class
    end

    total = 0
    for i in 0..100
      total += Class().count()
      total += Inherit1().count()
      total += Inherit2().count()
    end

    assert getTotal() == total
    lang.gc()
    assert getTotal() == 0
  """

  # Type-binding class can be inherited by native class, too.
  # Being inherited by script class is ok but a lot bit hacky.
  # (need to copy a internal attribute of class named `_nimid`).
  type
    Shape = object
      name: string
      sides: seq[int]

  vm.def:
    [Module]:
      [Shape] of Shape:
        "_init" do (self: var Shape, name: string, sides: varargs[int]):
          self.name = name
          self.sides = @sides

        "_str" do (self: Shape) -> string:
          return fmt"{self.name}({self.sides})"

        perimeter do (self: Shape) -> int:
          for s in self.sides:
            result += s

      [Triangle] is [Shape]:
        "_init":
          assert args.len == 3
          # Injected `super` template for code block emulate
          # super keyword in PocketLang.
          super(vm.new("Triangle"), args[0], args[1], args[2])

  vm.run """
    from Module import Shape, Triangle

    class Rectangle is Shape
      def _init(a, b, c, d)
        super("Rectangle", a, b, c, d)
      end
    end
    Rectangle._nimid = Shape._nimid # hacky

    assert Triangle(3, 4, 5).perimeter() == 12
    assert Rectangle(4, 6, 4, 6).perimeter() == 20
  """
